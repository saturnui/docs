var __defProp = Object.defineProperty;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp.call(b, prop))
      __defNormalProp(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    }
  return a;
};
var __publicField = (obj, key, value) => {
  __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};
const COOKIE_PREFIX = "";
const isIPAddress = (val) => {
  return /^(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)$/.test(val);
};
const parseHostname = (url) => {
  let hostname;
  if (url.indexOf("//") > -1) {
    hostname = url.split("/")[2];
  } else {
    hostname = url.split("/")[0];
  }
  hostname = hostname.split(":")[0];
  hostname = hostname.split("?")[0];
  return hostname;
};
const parseDomain = (url) => {
  let hostname = parseHostname(url);
  if (hostname === "localhost") {
    return hostname;
  }
  let slices = hostname.split(".");
  return slices[slices.length - 2] + "." + slices[slices.length - 1];
};
const setCookie = (key, val, expiresAt) => {
  let domain = location.hostname;
  if (!isIPAddress(domain) && domain !== "localhost") {
    domain = "." + parseDomain(domain);
  }
  let expires = "";
  let d = new Date();
  if (expiresAt) {
    d.setTime(expiresAt);
    expires = "expires=" + d.toUTCString();
  }
  document.cookie = COOKIE_PREFIX + key + "=" + val + ";" + expires + ";path=/;SameSite=None;Secure;Domain=" + domain;
};
const getCookie = (key) => {
  let name = COOKIE_PREFIX + key + "=";
  let decodedCookie = decodeURIComponent(document.cookie);
  let ca = decodedCookie.split(";");
  for (let i = 0; i < ca.length; i++) {
    let c = ca[i];
    while (c.charAt(0) === " ") {
      c = c.substring(1);
    }
    if (c.indexOf(name) === 0) {
      return c.substring(name.length, c.length);
    }
  }
  return "";
};
const uuid = () => {
  return "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g, function(c) {
    var r = Math.random() * 16 | 0, v = c == "x" ? r : r & 3 | 8;
    return v.toString(16);
  });
};
const deviceKey = "device";
let deviceId = getCookie(deviceKey);
if (!deviceId) {
  deviceId = uuid();
  setCookie(deviceKey, deviceId, new Date(2100, 1, 1).getTime());
}
const config = {
  baseUrl: `${"https://api.auth.uvisity.com"}`,
  deviceId,
  validatePassword: void 0
};
const setBaseUrl = (url) => {
  config.baseUrl = url;
};
const setMode = (mode = "production") => {
  switch (mode.toLowerCase()) {
    case "development":
      config.baseUrl = `${"http://localhost:5000"}`;
      break;
    case "staging":
      config.baseUrl = `${"https://staging.api.auth.uvisity.com"}`;
      break;
    default:
      config.baseUrl = `${"https://api.auth.uvisity.com"}`;
  }
};
const setValidatePassword = (validate2) => {
  config.validatePassword = validate2;
};
var tester = /^[-!#$%&'*+\/0-9=?A-Z^_a-z{|}~](\.?[-!#$%&'*+\/0-9=?A-Z^_a-z`{|}~])*@[a-zA-Z0-9](-*\.?[a-zA-Z0-9])*\.[a-zA-Z](-?[a-zA-Z0-9])+$/;
var validate = function(email) {
  if (!email)
    return false;
  if (email.length > 254)
    return false;
  var valid = tester.test(email);
  if (!valid)
    return false;
  var parts = email.split("@");
  if (parts[0].length > 64)
    return false;
  var domainParts = parts[1].split(".");
  if (domainParts.some(function(part) {
    return part.length > 63;
  }))
    return false;
  return true;
};
const _HttpClient = class {
  constructor(config2) {
    __publicField(this, "options", {
      baseUrl: "",
      beforeUrlHandler: (ctx) => {
        return ctx;
      },
      urlHandler: (baseUrl, uri, queryParams = {}) => {
        const ctx = { baseUrl, uri, queryParams };
        if (this.options.beforeUrlHandler) {
          this.options.beforeUrlHandler(ctx);
        }
        let url = `${ctx.baseUrl}${ctx.uri}`;
        if (uri.includes("://")) {
          url = uri;
        }
        const queryStr = this._queryParamsToString(queryParams);
        if (queryStr) {
          return `${url}?${queryStr}`;
        }
        return url;
      },
      beforeRequestHandler: async (_, request) => {
        return request;
      },
      requestHandler: async (ctx, request) => {
        if (this.options.beforeRequestHandler) {
          request = await this.options.beforeRequestHandler(ctx, request);
        }
        return request;
      },
      responseHandler: (response) => {
        return response.text().then((text) => {
          let data = text;
          if (this.isJson(text)) {
            data = JSON.parse(text);
          }
          if (!response.ok) {
            const error = data && data.message || response.statusText;
            return Promise.reject(error);
          }
          if (this.options.afterResponseHandler) {
            return this.options.afterResponseHandler({ data });
          }
        });
      },
      afterResponseHandler: (result) => {
        return result;
      }
    });
    Object.assign(this.options, config2 || {});
  }
  isJson(str = "null") {
    try {
      JSON.parse(str);
    } catch (e) {
      return false;
    }
    return true;
  }
  _queryParamsToString(params) {
    const urlParams = new URLSearchParams();
    for (let k in params) {
      urlParams.append(k, params[k]);
    }
    return urlParams.toString();
  }
  async get(uri, query) {
    let url = "";
    if (this.options.urlHandler) {
      const baseUrl = this.options.baseUrl || "";
      url = this.options.urlHandler(baseUrl, uri, query);
      const ctx = { baseUrl: url };
      let request;
      if (this.options.requestHandler) {
        request = await this.options.requestHandler(ctx, {
          method: "GET",
          mode: "cors",
          cache: "no-cache",
          headers: __spreadValues({}, _HttpClient.defaultHeaders)
        });
        return fetch(url, request).then(this.options.responseHandler);
      }
    }
  }
  async post(uri, body, query, headers = {}) {
    let url = "";
    if (this.options.urlHandler) {
      const baseUrl = this.options.baseUrl || "";
      url = this.options.urlHandler(baseUrl, uri, query);
      const ctx = { baseUrl: url };
      if (this.options.requestHandler) {
        const request = await this.options.requestHandler(ctx, {
          method: "POST",
          mode: "cors",
          cache: "no-cache",
          headers: __spreadValues(__spreadValues({}, _HttpClient.defaultHeaders), headers),
          body: JSON.stringify(body)
        });
        return fetch(url, request).then(this.options.responseHandler);
      }
    }
  }
  async put(uri, body, query) {
    let url = "";
    if (this.options.urlHandler) {
      const baseUrl = this.options.baseUrl || "";
      url = this.options.urlHandler(baseUrl, uri, query);
      const ctx = { baseUrl: url };
      if (this.options.requestHandler) {
        const request = await this.options.requestHandler(ctx, {
          method: "PUT",
          mode: "cors",
          cache: "no-cache",
          headers: __spreadValues({}, _HttpClient.defaultHeaders),
          body: JSON.stringify(body)
        });
        return fetch(url, request).then(this.options.responseHandler);
      }
    }
  }
  async patch(uri, body, query) {
    let url = "";
    if (this.options.urlHandler) {
      const baseUrl = this.options.baseUrl || "";
      url = this.options.urlHandler(baseUrl, uri, query);
      const ctx = { baseUrl: url };
      if (this.options.requestHandler) {
        const request = await this.options.requestHandler(ctx, {
          method: "PATCH",
          mode: "cors",
          cache: "no-cache",
          headers: __spreadValues({}, _HttpClient.defaultHeaders),
          body: JSON.stringify(body)
        });
        return fetch(url, request).then(this.options.responseHandler);
      }
    }
  }
  async delete(uri, query) {
    let url = "";
    if (this.options.urlHandler) {
      const baseUrl = this.options.baseUrl || "";
      url = this.options.urlHandler(baseUrl, uri, query);
      const ctx = { baseUrl: url };
      if (this.options.requestHandler) {
        const request = await this.options.requestHandler(ctx, {
          method: "DELETE",
          mode: "cors",
          cache: "no-cache",
          headers: __spreadValues({}, _HttpClient.defaultHeaders)
        });
        return fetch(url, request).then(this.options.responseHandler);
      }
    }
  }
  static instance(config2) {
    if (!this._instance) {
      this._instance = new _HttpClient(config2);
    }
    return this._instance;
  }
  static create(config2) {
    return new _HttpClient(config2);
  }
};
let HttpClient = _HttpClient;
__publicField(HttpClient, "_instance");
__publicField(HttpClient, "defaultHeaders", { "Content-Type": "application/json" });
const ACCESS_TOKEN_COOKIE = "access";
const REFRESH_TOKEN_COOKIE = "refresh";
const getAccessToken = () => {
  return getCookie(ACCESS_TOKEN_COOKIE);
};
const setAccessToken = (token, expirationInSeconds = 0) => {
  setCookie(ACCESS_TOKEN_COOKIE, token, new Date(expirationInSeconds * 1e3).getTime());
};
const getRefreshToken = () => {
  return getCookie(REFRESH_TOKEN_COOKIE);
};
const setRefreshToken = (token) => {
  setCookie(REFRESH_TOKEN_COOKIE, token, new Date(2100, 1, 1).getTime());
};
const clearTokens = () => {
  setCookie(ACCESS_TOKEN_COOKIE, "", Date.now());
  setCookie(REFRESH_TOKEN_COOKIE, "", Date.now());
};
var Provider;
(function(Provider2) {
  Provider2["APPLE"] = "apple";
  Provider2["FACEBOOK"] = "facebook";
  Provider2["GITHUB"] = "github";
  Provider2["GOOGLE"] = "google";
  Provider2["INSTAGRAM"] = "instagram";
  Provider2["LINKEDIN"] = "linkedin";
  Provider2["MICROSOFT"] = "microsoft";
  Provider2["TWITTER"] = "twitter";
})(Provider || (Provider = {}));
var CodeType;
(function(CodeType2) {
  CodeType2["REFRESH_TOKEN"] = "refresh_token";
  CodeType2["EMAIL_VERIFY"] = "email_verify";
  CodeType2["USERNAME_CHANGE"] = "username_change";
  CodeType2["USERNAME_VERIFY"] = "username_verify";
  CodeType2["PASSWORD_RESET"] = "password_reset";
  CodeType2["TWO_FACTOR_RESET"] = "two_factor_reset";
})(CodeType || (CodeType = {}));
const getCode = async (type, code) => {
  let data, error;
  try {
    const { data: data2 } = await httpClient.get("/code", { type, code });
    return { data: data2, error };
  } catch (error2) {
    return { data, error: error2 };
  }
};
const exchangeCodeForRefreshToken = async (code) => {
  let data, error;
  try {
    const { data: data2 } = await httpClient.post("/token/exchange", { code });
    setRefreshToken(data2.refreshToken);
    setAccessToken(data2.accessToken, data2.expires);
    return { data: data2, error };
  } catch (error2) {
    return { data, error: error2 };
  }
};
const createAccessToken = async (refreshToken) => {
  let data, error;
  try {
    const { data: data2 } = await httpClient.post("/token", {
      refreshToken
    });
    const accessToken = (data2 == null ? void 0 : data2.accessToken) || "";
    setAccessToken(accessToken, data2 == null ? void 0 : data2.expires);
    return { data: data2, error };
  } catch (error2) {
    clearTokens();
    return { data, error: error2 };
  }
};
const httpClient = HttpClient.create({
  beforeUrlHandler: (ctx) => {
    ctx.baseUrl = config.baseUrl;
    return ctx;
  },
  beforeRequestHandler: async (_, request) => {
    request.headers["x-device"] = config.deviceId;
    return request;
  }
});
const authClient = HttpClient.create({
  beforeUrlHandler: (ctx) => {
    ctx.baseUrl = config.baseUrl;
    return ctx;
  },
  beforeRequestHandler: async (_, request) => {
    request.headers["x-device"] = config.deviceId;
    let accessToken = getAccessToken();
    if (!accessToken) {
      const refreshToken = getRefreshToken();
      if (refreshToken) {
        const { data, error } = await createAccessToken(refreshToken);
        if (error) {
          throw error;
        }
        accessToken = data.accessToken;
      } else {
        throw new Error("missing refresh token");
      }
    }
    request.headers["authorization"] = `Bearer ${accessToken}`;
    return request;
  }
});
const signupWithEmailPassword = async (credentials) => {
  let data, error;
  if (!validate(credentials.email)) {
    return { data, error: { message: "invalid email" } };
  }
  if (config.validatePassword && !config.validatePassword(credentials.password)) {
    return { data, error: { message: "invalid password" } };
  }
  try {
    clearTokens();
    const { data: data2 } = await httpClient.post("/auth/signup", credentials);
    return { data: data2, error };
  } catch (error2) {
    return { data, error: error2 };
  }
};
const signinWithEmailPassword = async (credentials) => {
  let data, error;
  try {
    clearTokens();
    const { data: data2 } = await httpClient.post("/auth/signin", credentials);
    setRefreshToken(data2.refreshToken);
    return { data: data2, error };
  } catch (error2) {
    return { data, error: error2 };
  }
};
const sendMagicLink = async (email) => {
  let data, error;
  try {
    clearTokens();
    const { data: data2 } = await httpClient.post("/auth/magiclink", { email });
    return { data: data2, error };
  } catch (error2) {
    return { data, error: error2 };
  }
};
const signout = async () => {
  let data, error;
  try {
    const { data: data2 } = await authClient.post("/auth/signout", {});
    clearTokens();
    return { data: data2, error };
  } catch (error2) {
    return { data, error: error2 };
  }
};
const signoutAllDevices = async () => {
  let data, error;
  try {
    const { data: data2 } = await authClient.post("/signout?all=true");
    clearTokens();
    return { data: data2, error };
  } catch (error2) {
    return { data, error: error2 };
  }
};
const getDevices = async () => {
  let data, error;
  try {
    const { data: data2 } = await authClient.get("/devices", { enable: false });
    return { data: data2, error };
  } catch (error2) {
    return { data, error: error2 };
  }
};
const revokeDevice = async (deviceId2) => {
  let data, error;
  try {
    const { data: data2 } = await authClient.delete("/devices/" + deviceId2);
    if (config.deviceId === deviceId2) {
      clearTokens();
    }
    return { data: data2, error };
  } catch (error2) {
    return { data, error: error2 };
  }
};
const revokeAllDevices = async () => {
  let data, error;
  try {
    const { data: data2 } = await authClient.delete("/devices");
    clearTokens();
    return { data: data2, error };
  } catch (error2) {
    return { data, error: error2 };
  }
};
const requestPasswordReset = async (email) => {
  let data, error;
  if (!validate(email)) {
    return { data, error: { message: "invalid email" } };
  }
  try {
    const { data: data2 } = await httpClient.post("/request/reset-password", { email });
    return { data: data2, error };
  } catch (error2) {
    return { data, error: error2 };
  }
};
const resetPassword = async (password, code) => {
  let data, error;
  if (config.validatePassword && !config.validatePassword(password)) {
    return { data, error: { message: "invalid password" } };
  }
  try {
    const { data: data2 } = await httpClient.post("/reset-password", { password, code });
    return { data: data2, error };
  } catch (error2) {
    return { data, error: error2 };
  }
};
const signupWithProvider = (provider) => {
  clearTokens();
  location.href = config.baseUrl + "/auth/" + provider + "?signup";
};
const signinWithProvider = (provider) => {
  location.href = config.baseUrl + "/auth/" + provider;
};
const linkProvider = (provider) => {
  location.href = config.baseUrl + "/auth/" + provider + "?link";
};
const getLinkedProviders = async () => {
  let data, error;
  try {
    const { data: data2 } = await authClient.get("/identities");
    return { data: data2, error };
  } catch (error2) {
    return { data, error: error2 };
  }
};
const enable2fa = async (token) => {
  let data, error;
  try {
    const { data: data2 } = await authClient.post("/2fa/enable", {
      token
    });
    return { data: data2, error };
  } catch (error2) {
    return { data, error: error2 };
  }
};
const disable2fa = async (token) => {
  let data, error;
  try {
    const { data: data2 } = await authClient.post("/2fa/disable", {
      token
    });
    return { data: data2, error };
  } catch (error2) {
    return { data, error: error2 };
  }
};
const disable2faAlt = async (code, password) => {
  let data, error;
  try {
    const { data: data2 } = await authClient.post("/2fa/disable", {
      code,
      password
    });
    return { data: data2, error };
  } catch (error2) {
    return { data, error: error2 };
  }
};
const sendDisable2faRequest = async () => {
  let data, error;
  try {
    const { data: data2 } = await authClient.post("/2fa/request", {});
    return { data: data2, error };
  } catch (error2) {
    return { data, error: error2 };
  }
};
const generateQRCode = async () => {
  let data, error;
  try {
    const { data: data2 } = await authClient.post("/2fa/qrcode", {});
    return { data: data2, error };
  } catch (error2) {
    return { data, error: error2 };
  }
};
const me = async () => {
  let data, error;
  try {
    const { data: data2 } = await authClient.get("/me");
    return { data: data2, error };
  } catch (error2) {
    return { data, error: error2 };
  }
};
const verifyCredentials = async (credentials) => {
  let data, error;
  try {
    const { data: data2 } = await httpClient.post("/verify/credentials", credentials);
    return { data: data2, error };
  } catch (error2) {
    return { data, error: error2 };
  }
};
const requestVerifyEmail = async () => {
  let data, error;
  try {
    const { data: data2 } = await httpClient.post("/request/verify-email");
    return { data: data2, error };
  } catch (error2) {
    return { data, error: error2 };
  }
};
const verifyEmail = async () => {
  let data, error;
  try {
    const { data: data2 } = await httpClient.post("/verify/email");
    return { data: data2, error };
  } catch (error2) {
    return { data, error: error2 };
  }
};
const requestChangeUsername = async () => {
  let data, error;
  try {
    const { data: data2 } = await httpClient.post("/request/change-username", {});
    return { data: data2, error };
  } catch (error2) {
    return { data, error: error2 };
  }
};
const requestNewUsername = async (email, code) => {
  let data, error;
  if (!validate(email)) {
    return { data, error: { message: "invalid email" } };
  }
  try {
    const { data: data2 } = await httpClient.post("/request/username", { email, code });
    return { data: data2, error };
  } catch (error2) {
    return { data, error: error2 };
  }
};
const verifyNewUsername = async (code) => {
  let data, error;
  try {
    const { data: data2 } = await httpClient.post("/verify/username", { code });
    return { data: data2, error };
  } catch (error2) {
    return { data, error: error2 };
  }
};
var index = {
  CodeType,
  Provider,
  setBaseUrl,
  setMode,
  setValidatePassword,
  signupWithEmailPassword,
  signinWithEmailPassword,
  requestMagicLink: sendMagicLink,
  signout,
  signoutAllDevices,
  authClient,
  httpClient,
  getCode,
  exchangeCodeForRefreshToken,
  getDevices,
  revokeAllDevices,
  revokeDevice,
  resetPassword,
  requestPasswordReset,
  getLinkedProviders,
  linkProvider,
  signinWithProvider,
  signupWithProvider,
  disable2fa,
  disable2faAlt,
  enable2fa,
  generateQRCode,
  sendDisable2faRequest,
  me,
  requestChangeUsername,
  requestNewUsername,
  requestVerifyEmail,
  verifyCredentials,
  verifyEmail,
  verifyNewUsername
};
export { index as default };
